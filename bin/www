#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require("../app");
var debug = require("debug")("smartst-backend:server");
var WebSocketServer = require("websocket").server;
var http = require("http");
var mongoose = require("mongoose");
var cors = require("../routes/cors");
const aedes = require("aedes")();

/**MongoDb server initializaction */
const connect = mongoose.connect(
  //"mongodb+srv://Stiquit:Peluza9709@cluster0.jcld4.mongodb.net/SmartSt?retryWrites=true&w=majority",
  "mongodb://localhost:27017/SmartSt",
  {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  }
);
connect.then(
  () => console.log(`connected to mongo server`),
  (err) => console.error(err)
);

/**HTTP Server initialization */ /**WebSocket Server initialization */ /** MQTT Server initialization */
const mqtt_server = require("net").createServer(aedes.handle);
const mqtt_port = 1883;
var webSocketPort = 8888;
var appPort = 5000;
var port = normalizePort(process.env.PORT || appPort);
app.set("port", port);
var server = http.createServer(app);
var mqtt = require("mqtt");

var mqttClient = mqtt.connect("mqtt://localhost:1883");
const wsServer = new WebSocketServer({ httpServer: server }, aedes.handle);

mqtt_server.listen(mqtt_port, () =>
  console.log(`Started listening at port ${mqtt_port}`)
);
server.listen(webSocketPort, () => {
  console.log("websocket server listening on port " + webSocketPort);
});
server.on("error", onError);
server.on("listening", onListening);
/*Aca al mqtt y se reciben los mensajes para la com full duplex */
var authenticate = require("../autenthicate");

wsServer.on("request", (request) => {
  if (cors.corsWhiteList.indexOf(request.origin) !== -1) {
    const connection = request.accept(null, request.origin);
    connection.on("message", (message) => {
      if (message.type == "utf8") {
        var data = JSON.parse(message.utf8Data);
        console.log(`User ${data.user}`);
        mqttClient.subscribe(`${data.topic}Reply`);
        console.log(`Publishing ${String(data.payload)} to: ${data.topic}`);
        mqttClient.publish(data.topic, String(data.payload));
        const date = new Date();
        /**Revisar funcionamiento creacion acciones por ws */
        // Action.create({
        //   user: data.user,
        //   device: data.device,
        //   payload: data.payload,
        //   day: date.getDay(),
        //   hour: `${date.getHours()}:${date.getMinutes()}`,
        // }).then((action) => {
        //   console.log(`Created new action: ${action}`);
        // });
        connection.sendUTF(
          JSON.stringify({
            Reply: "hold",
          })
        );
      }
      mqttClient.on("message", (topic, payload) => {
        console.log(`MQTT message to ${topic}: ${String(payload)}`);
        connection.sendUTF(
          JSON.stringify({
            Reply: payload.toString(),
          })
        );
        mqttClient.removeAllListeners();
      });
    });
  }
});
/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== "listen") {
    throw error;
  }

  var bind = typeof port === "string" ? "Pipe " + port : "Port " + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case "EACCES":
      console.error(bind + " requires elevated privileges");
      process.exit(1);
      break;
    case "EADDRINUSE":
      console.error(bind + " is already in use");
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === "string" ? "pipe " + addr : "port " + addr.port;
  debug("Listening on " + bind);
}
